// Code generated by sage-ci. DO NOT EDIT.

package main

import (
	"context"
	"fmt"
	"os"

	"github.com/fredrikaverpil/sage-ci/tools/sggolangcilint"
	"github.com/fredrikaverpil/sage-ci/tools/sgstylua"
	"github.com/fredrikaverpil/sage-ci/workflows"
	"go.einride.tech/sage/sg"
	"go.einride.tech/sage/tools/sggo"
	"go.einride.tech/sage/tools/sguv"
)

// SyncGHA syncs GitHub workflows.
func SyncGHA(ctx context.Context) error {
	if shouldSkipTarget("SyncGHA", "") {
		return nil
	}
	return workflows.Sync(cfg)
}

// --- Go targets ---

// GoModTidy runs go mod tidy.
func GoModTidy(ctx context.Context) error {
	for _, module := range cfg.GoModules {
		if shouldSkipTarget("GoModTidy", module) {
			continue
		}
		sg.Logger(ctx).Printf("running go mod tidy in %s...", module)
		cmd := sg.Command(ctx, "go", "mod", "tidy", "-v")
		cmd.Dir = sg.FromGitRoot(module)
		if err := cmd.Run(); err != nil {
			return err
		}
	}
	return nil
}

// GoLint runs golangci-lint with --fix.
func GoLint(ctx context.Context) error {
	for _, module := range cfg.GoModules {
		if shouldSkipTarget("GoLint", module) {
			continue
		}
		sg.Logger(ctx).Printf("running golangci-lint --fix in %s...", module)
		cmd := sggolangcilint.Command(ctx, "run", "--fix", "--allow-parallel-runners", "./...")
		cmd.Dir = sg.FromGitRoot(module)
		if err := cmd.Run(); err != nil {
			return err
		}
	}
	return nil
}

// GoFormat applies Go formatting using gofmt.
func GoFormat(ctx context.Context) error {
	for _, module := range cfg.GoModules {
		if shouldSkipTarget("GoFormat", module) {
			continue
		}
		sg.Logger(ctx).Printf("applying gofmt in %s...", module)
		cmd := sg.Command(ctx, "gofmt", "-w", ".")
		cmd.Dir = sg.FromGitRoot(module)
		if err := cmd.Run(); err != nil {
			return err
		}
	}
	return nil
}

// GoTest runs Go tests.
func GoTest(ctx context.Context) error {
	for _, module := range cfg.GoModules {
		if shouldSkipTarget("GoTest", module) {
			continue
		}
		sg.Logger(ctx).Printf("running go test in %s...", module)
		cmd := sggo.TestCommand(ctx)
		cmd.Dir = sg.FromGitRoot(module)
		if err := cmd.Run(); err != nil {
			return err
		}
	}
	return nil
}

// GoVulncheck runs govulncheck.
func GoVulncheck(ctx context.Context) error {
	for _, module := range cfg.GoModules {
		if shouldSkipTarget("GoVulncheck", module) {
			continue
		}
		sg.Logger(ctx).Printf("running govulncheck in %s...", module)
		cmd := sg.Command(ctx, "go", "run", "golang.org/x/vuln/cmd/govulncheck@latest", "./...")
		cmd.Dir = sg.FromGitRoot(module)
		if err := cmd.Run(); err != nil {
			return err
		}
	}
	return nil
}

// --- Python targets ---

// PythonSync runs uv sync to install dependencies.
func PythonSync(ctx context.Context) error {
	for _, module := range cfg.PythonModules {
		if shouldSkipTarget("PythonSync", module) {
			continue
		}
		sg.Logger(ctx).Printf("running uv sync in %s...", module)
		cmd := sguv.Command(ctx, "sync", "--all-groups")
		cmd.Dir = sg.FromGitRoot(module)
		if err := cmd.Run(); err != nil {
			return err
		}
	}
	return nil
}

// PythonFormat applies Python formatting using ruff format.
func PythonFormat(ctx context.Context) error {
	sg.Deps(ctx, PythonSync)
	for _, module := range cfg.PythonModules {
		if shouldSkipTarget("PythonFormat", module) {
			continue
		}
		sg.Logger(ctx).Printf("applying ruff format in %s...", module)
		cmd := sguv.Command(ctx, "run", "ruff", "format", ".")
		cmd.Dir = sg.FromGitRoot(module)
		if err := cmd.Run(); err != nil {
			return err
		}
	}
	return nil
}

// PythonLint runs ruff check with --fix.
func PythonLint(ctx context.Context) error {
	sg.Deps(ctx, PythonSync)
	for _, module := range cfg.PythonModules {
		if shouldSkipTarget("PythonLint", module) {
			continue
		}
		sg.Logger(ctx).Printf("running ruff check --fix in %s...", module)
		cmd := sguv.Command(ctx, "run", "ruff", "check", "--fix", ".")
		cmd.Dir = sg.FromGitRoot(module)
		if err := cmd.Run(); err != nil {
			return err
		}
	}
	return nil
}

// PythonMypy runs mypy type checking.
func PythonMypy(ctx context.Context) error {
	sg.Deps(ctx, PythonSync)
	for _, module := range cfg.PythonModules {
		if shouldSkipTarget("PythonMypy", module) {
			continue
		}
		sg.Logger(ctx).Printf("running mypy in %s...", module)
		cmd := sguv.Command(ctx, "run", "mypy", ".")
		cmd.Dir = sg.FromGitRoot(module)
		if err := cmd.Run(); err != nil {
			return err
		}
	}
	return nil
}

// PythonTest runs pytest.
func PythonTest(ctx context.Context) error {
	sg.Deps(ctx, PythonSync)
	for _, module := range cfg.PythonModules {
		if shouldSkipTarget("PythonTest", module) {
			continue
		}
		sg.Logger(ctx).Printf("running pytest in %s...", module)
		cmd := sguv.Command(ctx, "run", "pytest", "-v")
		cmd.Dir = sg.FromGitRoot(module)
		if err := cmd.Run(); err != nil {
			return err
		}
	}
	return nil
}

// --- Lua targets ---

// LuaFormat applies Lua formatting using stylua.
func LuaFormat(ctx context.Context) error {
	for _, module := range cfg.LuaModules {
		if shouldSkipTarget("LuaFormat", module) {
			continue
		}
		sg.Logger(ctx).Printf("applying stylua format in %s...", module)
		cmd := sgstylua.Command(ctx, ".")
		cmd.Dir = sg.FromGitRoot(module)
		if err := cmd.Run(); err != nil {
			return err
		}
	}
	return nil
}

// GitDiffCheck fails if there are uncommitted changes (only in CI).
func GitDiffCheck(ctx context.Context) error {
	hasDiff := sg.Command(ctx, "git", "diff", "--exit-code").Run() != nil ||
		sg.Command(ctx, "git", "diff", "--cached", "--exit-code").Run() != nil
	if !hasDiff {
		return nil
	}
	if os.Getenv("CI") == "" {
		sg.Logger(ctx).Println("warning: uncommitted changes detected")
		return nil
	}
	_ = sg.Command(ctx, "git", "diff").Run()
	return fmt.Errorf("uncommitted changes detected")
}

// --- Orchestration ---

// RunSyncedSerial runs all mutating targets serially.
func RunSyncedSerial(ctx context.Context) error {
	sg.SerialDeps(ctx,
		SyncGHA,
		GoModTidy,
		GoFormat,
		GoLint,
		PythonSync,
		PythonFormat,
		PythonLint,
		LuaFormat,
	)
	return nil
}

// RunSynced runs all non-mutating targets in parallel.
func RunSynced(ctx context.Context) error {
	sg.Deps(ctx,
		GoTest,
		GoVulncheck,
		PythonMypy,
		PythonTest,
	)
	return nil
}

func shouldSkipTarget(target, module string) bool {
	skippedModules, ok := skipTargets[target]
	if !ok {
		return false
	}
	for _, m := range skippedModules {
		if m == "*" || m == module {
			return true
		}
	}
	return false
}
